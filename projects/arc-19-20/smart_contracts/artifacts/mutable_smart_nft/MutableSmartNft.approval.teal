#pragma version 10

smart_contracts.mutable_smart_nft.contract.MutableSmartNft.approval_program:
    // smart_contracts/mutable_smart_nft/contract.py:135
    // class MutableSmartNft(ARC20Contract):
    method "create_application(string,uint64,uint64[])void"
    method "apply_for_nft(account,string,string,string,byte[])void"
    txna ApplicationArgs 0
    match main_create_application_route@1 main_apply_for_nft_route@2
    err // reject transaction

main_create_application_route@1:
    // smart_contracts/mutable_smart_nft/contract.py:140
    // @abimethod(allow_actions=["NoOp"], create="require")
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    !
    assert // is creating
    // smart_contracts/mutable_smart_nft/contract.py:135
    // class MutableSmartNft(ARC20Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    // smart_contracts/mutable_smart_nft/contract.py:140
    // @abimethod(allow_actions=["NoOp"], create="require")
    callsub create_application
    int 1
    return

main_apply_for_nft_route@2:
    // smart_contracts/mutable_smart_nft/contract.py:148
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/mutable_smart_nft/contract.py:135
    // class MutableSmartNft(ARC20Contract):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    extract 2 0
    txna ApplicationArgs 5
    extract 2 0
    // smart_contracts/mutable_smart_nft/contract.py:148
    // @abimethod()
    callsub apply_for_nft
    int 1
    return


// smart_contracts.mutable_smart_nft.contract.MutableSmartNft.create_application(name: bytes, counter: uint64, criterias: bytes) -> void:
create_application:
    // smart_contracts/mutable_smart_nft/contract.py:140-143
    // @abimethod(allow_actions=["NoOp"], create="require")
    // def create_application(
    //     self, name: String, counter: UInt64, criterias: DynamicArray[ARC4UInt64]
    // ) -> None:
    proto 3 0
    // smart_contracts/mutable_smart_nft/contract.py:136
    // counter: UInt64
    byte "counter"
    // smart_contracts/mutable_smart_nft/contract.py:144
    // self.counter = counter
    frame_dig -2
    app_global_put
    // smart_contracts/mutable_smart_nft/contract.py:137
    // name: String
    byte "name"
    // smart_contracts/mutable_smart_nft/contract.py:145
    // self.name = name
    frame_dig -3
    app_global_put
    // smart_contracts/mutable_smart_nft/contract.py:146
    // self.criterias = criterias.copy()
    byte "criterias"
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.mutable_smart_nft.contract.MutableSmartNft.apply_for_nft(reserve_address: bytes, url_template: bytes, asset_name: bytes, unit_name: bytes, metadata_hash: bytes) -> void:
apply_for_nft:
    // smart_contracts/mutable_smart_nft/contract.py:148-156
    // @abimethod()
    // def apply_for_nft(
    //     self,
    //     reserve_address: Account,
    //     url_template: String,
    //     asset_name: String,
    //     unit_name: String,
    //     metadata_hash: Bytes,
    // ) -> None:
    proto 5 0
    // smart_contracts/mutable_smart_nft/contract.py:157-158
    // # assert Txn.sender != Global.creator_address
    // assert self.criterias.length != 0, "Length should not be zero"
    int 0
    // smart_contracts/mutable_smart_nft/contract.py:146
    // self.criterias = criterias.copy()
    byte "criterias"
    // smart_contracts/mutable_smart_nft/contract.py:157-158
    // # assert Txn.sender != Global.creator_address
    // assert self.criterias.length != 0, "Length should not be zero"
    app_global_get_ex
    assert // check self.criterias exists
    int 0
    extract_uint16
    assert // Length should not be zero
    // smart_contracts/mutable_smart_nft/contract.py:160
    // total=UInt64(1),
    int 1
    // smart_contracts/mutable_smart_nft/contract.py:161
    // decimals=UInt32(0),
    byte 0x00000000
    // smart_contracts/mutable_smart_nft/contract.py:162
    // default_frozen=True,
    int 1
    // smart_contracts/mutable_smart_nft/contract.py:159-171
    // token = self.asset_create(
    //     total=UInt64(1),
    //     decimals=UInt32(0),
    //     default_frozen=True,
    //     unit_name=unit_name,
    //     name=asset_name,
    //     url=url_template,
    //     metadata_hash=metadata_hash,
    //     manager_addr=Global.current_application_address,
    //     reserve_addr=reserve_address,
    //     freeze_addr=Global.current_application_address,
    //     clawback_addr=Global.current_application_address,
    // )
    frame_dig -2
    frame_dig -3
    frame_dig -4
    frame_dig -1
    // smart_contracts/mutable_smart_nft/contract.py:167
    // manager_addr=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/mutable_smart_nft/contract.py:159-171
    // token = self.asset_create(
    //     total=UInt64(1),
    //     decimals=UInt32(0),
    //     default_frozen=True,
    //     unit_name=unit_name,
    //     name=asset_name,
    //     url=url_template,
    //     metadata_hash=metadata_hash,
    //     manager_addr=Global.current_application_address,
    //     reserve_addr=reserve_address,
    //     freeze_addr=Global.current_application_address,
    //     clawback_addr=Global.current_application_address,
    // )
    frame_dig -5
    // smart_contracts/mutable_smart_nft/contract.py:169
    // freeze_addr=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/mutable_smart_nft/contract.py:170
    // clawback_addr=Global.current_application_address,
    dup
    // smart_contracts/mutable_smart_nft/contract.py:159-171
    // token = self.asset_create(
    //     total=UInt64(1),
    //     decimals=UInt32(0),
    //     default_frozen=True,
    //     unit_name=unit_name,
    //     name=asset_name,
    //     url=url_template,
    //     metadata_hash=metadata_hash,
    //     manager_addr=Global.current_application_address,
    //     reserve_addr=reserve_address,
    //     freeze_addr=Global.current_application_address,
    //     clawback_addr=Global.current_application_address,
    // )
    callsub asset_create
    pop
    retsub


// smart_contracts.mutable_smart_nft.contract.ARC20Contract.asset_create(total: uint64, decimals: bytes, default_frozen: uint64, unit_name: bytes, name: bytes, url: bytes, metadata_hash: bytes, manager_addr: bytes, reserve_addr: bytes, freeze_addr: bytes, clawback_addr: bytes) -> uint64:
asset_create:
    // smart_contracts/mutable_smart_nft/contract.py:18-32
    // @subroutine
    // def asset_create(
    //     self,
    //     total: UInt64,
    //     decimals: UInt32,
    //     default_frozen: bool,
    //     unit_name: String,
    //     name: String,
    //     url: String,
    //     metadata_hash: Bytes,
    //     manager_addr: Account,
    //     reserve_addr: Account,
    //     freeze_addr: Account,
    //     clawback_addr: Account,
    // ) -> Asset:
    proto 11 1
    // smart_contracts/mutable_smart_nft/contract.py:34-46
    // itxn.AssetConfig(
    //     unit_name=unit_name,
    //     asset_name=name,
    //     total=total,
    //     manager=manager_addr,
    //     freeze=freeze_addr,
    //     reserve=reserve_addr,
    //     clawback=clawback_addr,
    //     url=url,
    //     default_frozen=default_frozen,
    //     fee=Global.min_txn_fee,
    // )
    // .submit()
    itxn_begin
    // smart_contracts/mutable_smart_nft/contract.py:44
    // fee=Global.min_txn_fee,
    global MinTxnFee
    frame_dig -9
    itxn_field ConfigAssetDefaultFrozen
    frame_dig -6
    itxn_field ConfigAssetURL
    frame_dig -1
    itxn_field ConfigAssetClawback
    frame_dig -3
    itxn_field ConfigAssetReserve
    frame_dig -2
    itxn_field ConfigAssetFreeze
    frame_dig -4
    itxn_field ConfigAssetManager
    frame_dig -11
    itxn_field ConfigAssetTotal
    frame_dig -7
    itxn_field ConfigAssetName
    frame_dig -8
    itxn_field ConfigAssetUnitName
    // smart_contracts/mutable_smart_nft/contract.py:34
    // itxn.AssetConfig(
    int acfg
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/mutable_smart_nft/contract.py:34-46
    // itxn.AssetConfig(
    //     unit_name=unit_name,
    //     asset_name=name,
    //     total=total,
    //     manager=manager_addr,
    //     freeze=freeze_addr,
    //     reserve=reserve_addr,
    //     clawback=clawback_addr,
    //     url=url,
    //     default_frozen=default_frozen,
    //     fee=Global.min_txn_fee,
    // )
    // .submit()
    itxn_submit
    // smart_contracts/mutable_smart_nft/contract.py:34-47
    // itxn.AssetConfig(
    //     unit_name=unit_name,
    //     asset_name=name,
    //     total=total,
    //     manager=manager_addr,
    //     freeze=freeze_addr,
    //     reserve=reserve_addr,
    //     clawback=clawback_addr,
    //     url=url,
    //     default_frozen=default_frozen,
    //     fee=Global.min_txn_fee,
    // )
    // .submit()
    // .created_asset
    itxn CreatedAssetID
    // smart_contracts/mutable_smart_nft/contract.py:50
    // return asset
    retsub
